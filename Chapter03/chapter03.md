# [3장] 코드에서 나는 악취

리팩토링을 언제 멈춰야 하는지를 판단하는 정확한 기준은 제시하지 않을 것이다.

왜냐하면 숙련된 사람의 직관만큼 정확한 기준은 없기 때문이다.

## 기이한 이름

이름만 보고도 무슨 일을 하고 어떻게 사용해야 하는지 명확히 할 수 있도록 짓는다.

## 중복 코드

똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하자.

## 긴 함수

긴 함수보다 짧은 함수가 코드를 이해하는데 더욱 도움이 된다.

짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법은 좋은 이름이다.

본문을 읽지 않고 이름만 보아도 어떤 일을 하는지 알 수 있다.

주석을 달아야 할 만한 부분은 함수로 만든다.

주석으로 설명하려던 것은 코드로 만들고, 함수 이름은 동작 방식이 아닌 의도를 나타낸다.

심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 단, 이름에 코드의 목적을 드러내야 한다.

## 전역 데이터

변수 캡슐화하기를 통해서 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 적용한다.

## 기능 편애

코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는데 주력한다.

## 반복되는 switch문

switch문은 모조리 조건부 로직을 다형성으로 바꾸기

중복된 switch문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 switch문들도 모두 찾아서 수정해야 하기 때문이다.

## 반복문

반복문을 파이프라인으로 바꾸기

필터나 맵 같은 파이프라인 연산을 사용하면 어떻게 처리되는지 쉽게 파악할 수 있다.

[https://medium.com/오늘의-프로그래밍/함수형-프로그래밍-pipe-c80dc7b389de](https://medium.com/%EC%98%A4%EB%8A%98%EC%9D%98-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-pipe-c80dc7b389de)

## 성의 없는 요소

원래는 풍성했던 클래스가 리팩토링을 거치면서 역할이 줄어들었을 수도 있다. 이 제거 작업은 함수 인라인화하기, 클래스 인라인하기로 처리한다. 상속을 사용했다면 계층 합치기를 적용한다.

## 추측성 일반화

‘나중에 필요할 거야’라는 생각으로 당장은 필요 없는 모든 종류의 후킹포인트와 특이 케이스 처리 조릭을 작성해둔 코드에서 풍긴다.

미리 작성한 부분은 실제로 사용된다면 다행이지만 그렇지 않으면 쓸대없는 낭비이다. 당장 눈앞에서 치워버리자

## 메시지 체인

한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로 객체 내비게이션 구조에 종속됐음을 의미한다.

## 주석

특정 코드 블록이 하는 일에 주석을 남기고 싶다면 함수 추출하기

이미 추출되어 있는 함수임에도 여전히 설명이 필요하다면 함수 선언 바꾸기

시스템이 동작하기 위한 선행조건을 명시하고 싶다면 어서션 추가하기

주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩토링해본다.
